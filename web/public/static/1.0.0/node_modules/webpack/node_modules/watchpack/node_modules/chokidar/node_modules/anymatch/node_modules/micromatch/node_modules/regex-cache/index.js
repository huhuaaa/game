define('webpack/node_modules/watchpack/node_modules/chokidar/node_modules/anymatch/node_modules/micromatch/node_modules/regex-cache/index', function(require, exports, module) {

  /*!
   * regex-cache <https://github.com/jonschlinkert/regex-cache>
   *
   * Copyright (c) 2015 Jon Schlinkert.
   * Licensed under the MIT license.
   */
  
  'use strict';
  
  var isPrimitive = require('webpack/node_modules/watchpack/node_modules/chokidar/node_modules/anymatch/node_modules/micromatch/node_modules/regex-cache/node_modules/is-primitive/index');
  var equal = require('webpack/node_modules/watchpack/node_modules/chokidar/node_modules/anymatch/node_modules/micromatch/node_modules/regex-cache/node_modules/is-equal-shallow/index');
  var basic = {};
  var cache = {};
  
  /**
   * Expose `regexCache`
   */
  
  module.exports = regexCache;
  
  /**
   * Memoize the results of a call to the new RegExp constructor.
   *
   * @param  {Function} fn [description]
   * @param  {String} str [description]
   * @param  {Options} options [description]
   * @param  {Boolean} nocompare [description]
   * @return {RegExp}
   */
  
  function regexCache(fn, str, opts) {
    var key = '_default_',
        regex,
        cached;
  
    if (!str && !opts) {
      if (typeof fn !== 'function') {
        return fn;
      }
      return basic[key] || (basic[key] = fn(str));
    }
  
    var isString = typeof str === 'string';
    if (isString) {
      if (!opts) {
        return basic[str] || (basic[str] = fn(str));
      }
      key = str;
    } else {
      opts = str;
    }
  
    cached = cache[key];
    if (cached && equal(cached.opts, opts)) {
      return cached.regex;
    }
  
    memo(key, opts, regex = fn(str, opts));
    return regex;
  }
  
  function memo(key, opts, regex) {
    cache[key] = { regex: regex, opts: opts };
  }
  
  /**
   * Expose `cache`
   */
  
  module.exports.cache = cache;
  module.exports.basic = basic;

});
