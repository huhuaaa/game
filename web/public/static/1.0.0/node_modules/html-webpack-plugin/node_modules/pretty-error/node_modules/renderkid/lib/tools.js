define('html-webpack-plugin/node_modules/pretty-error/node_modules/renderkid/lib/tools', function(require, exports, module) {

  var process = require('webpack/node_modules/node-libs-browser/node_modules/process/browser');
  // Generated by CoffeeScript 1.9.3
  'use strict';
  
  var htmlparser, object, _objectToDom, self;
  
  htmlparser = require('html-webpack-plugin/node_modules/pretty-error/node_modules/renderkid/node_modules/htmlparser2/lib/index');
  
  object = require('html-webpack-plugin/node_modules/pretty-error/node_modules/renderkid/node_modules/utila/scripts/js/lib/utila').object;
  
  _objectToDom = require('html-webpack-plugin/node_modules/pretty-error/node_modules/renderkid/node_modules/dom-converter/scripts/js/lib/domConverter').objectToDom;
  
  module.exports = self = {
    repeatString: function repeatString(str, times) {
      var i, j, output, ref;
      output = '';
      for (i = j = 0, ref = times; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output += str;
      }
      return output;
    },
    toDom: function toDom(subject) {
      if (typeof subject === 'string') {
        return self.stringToDom(subject);
      } else if (object.isBareObject(subject)) {
        return self._objectToDom(subject);
      } else {
        throw Error("tools.toDom() only supports strings and objects");
      }
    },
    stringToDom: function stringToDom(string) {
      var handler, parser;
      handler = new htmlparser.DomHandler();
      parser = new htmlparser.Parser(handler);
      parser.write(string);
      parser.end();
      return handler.dom;
    },
    _fixQuotesInDom: function _fixQuotesInDom(input) {
      var j, len, node;
      if (Array.isArray(input)) {
        for (j = 0, len = input.length; j < len; j++) {
          node = input[j];
          self._fixQuotesInDom(node);
        }
        return input;
      }
      node = input;
      if (node.type === 'text') {
        return node.data = self._quoteNodeText(node.data);
      } else {
        return self._fixQuotesInDom(node.children);
      }
    },
    objectToDom: function objectToDom(o) {
      if (!Array.isArray(o)) {
        if (!object.isBareObject(o)) {
          throw Error("objectToDom() only accepts a bare object or an array");
        }
      }
      return self._fixQuotesInDom(_objectToDom(o));
    },
    quote: function quote(str) {
      return String(str).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\ /g, '&sp;').replace(/\n/g, '<br />');
    },
    _quoteNodeText: function _quoteNodeText(text) {
      return String(text).replace(/\&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\ /g, '&sp;').replace(/\n/g, "&nl;");
    },
    getCols: function getCols() {
      var cols, tty;
      tty = require('tty');
      cols = (function () {
        try {
          if (tty.isatty(1) && tty.isatty(2)) {
            if (process.stdout.getWindowSize) {
              return process.stdout.getWindowSize(1)[0];
            } else if (tty.getWindowSize) {
              return tty.getWindowSize()[1];
            } else if (process.stdout.columns && process.stdout.rows) {
              return process.stdout.rows;
            }
          }
        } catch (_error) {}
      })();
      if (typeof cols === 'number') {
        return cols;
      } else {
        return 80;
      }
    }
  };

});
